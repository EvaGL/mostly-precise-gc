Указатели заводятся: gc_ptr< Typename>
А память выделяется : gc_new <Typename>(size_t  size)
Для корректой работы GC необходимо заменить ВСЕ указатели на объекты класса gc_ptr.
ex:(необходимые изменение кода для использования GC)
1.	int* a = new int[5];
	→
	gc_ptr<int*> a =  gc_new<int*>(5);
2.	struct List {
		...
		List* next;
	}
	→
	struct List {
		...
		gc_ptr<List*> next;
	};
Механизм поиска рутов:
1) Внутри gc_new(ф-ия отведения памяти под gc_ptr) выставляется флаг new_active – декларирует место (куча или стек) создания объекта класса gc_ptr.
2) При вызове конструктора gc_ptr для стекового объекта в список all_ptr(список всех существующих стековых объектов класса gc_ptr) добавляется указатель на this. В случае, когда new_active неактивен, т.е. создается стековый объект, внутри объекта класса gc_ptr заводится указатель(me) на соответствующий ему элемент в списке all_ptr, иначе me == 0.
3) В деструкторе gc_ptr происходит удаление себя из all_ptr, т.к. мы знаем me (он же указатель на себя в списке),  удаление происходит за О(1).
Механизм создания объектов в куче:
1) Все происходит внутри функции gc_new.
2) Объем выделяемой памяти первосходит память, занимаемую объектом, на размер слова(указатель на начало метаинформации) и размер метаинформации(4 машинных слова).
3) В начале блока памяти кладется метаинформация, затем указатель на начало метаинформации, за ней сам объект. Объект конструируется с использованием placement new.
4) Пользователю  возвращается указатель на начало объекта.
5) Указатель на начало объекта кладется в  вектор ptr_in_heap(нужно для того, чтобы отслеживать  все объекты в куче). 
Создание и хранение метаинформации:
1) В метаинформации хранится ссылка на обертку(box) и mark_bit(для сборки мусора).
2) Обертка создается в единственном экземпляре для каждого типа.
3) В обертке хранятся  смещения указателей вложенных объектов типа gc_ptr от носительно указателя на объект (нужно для того, чтобы уметь ходить по всем достижимым объектам).
4) В функции gc_new  все смещения записываются в вектор offsets. Offsets получается следующим образом:
А) внутри конструктора gc_ptr, при активном флаге new_active, указатель на this кладется в глобальный список ptr_in_heap(все gc_ptr кучи). 
Б) смещения получаются взятием разности между значением в глобальном массиве и указателем на начало объекта. 
Сборка мусора:
1) Функция сборки мусора: mark_and_sweep –  вызывается внутри  gc_new каждые К(некоторая константа) байт выделений памяти.
2) Mark_and_Sweep делает следующее:
А) С помощью функции go обходит и помечает(устанавливает mbit = 1) все достижимые из рутов  объекты.
Б) Удаляет отовсюду недостижимые объекты.
В) Обновляет ptr_in_heap
Г) У всех выживших объектов устанавливает mbit = 0.
